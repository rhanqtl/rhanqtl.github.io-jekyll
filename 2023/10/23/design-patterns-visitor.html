<h1 id="动机">动机</h1>

<p>思考一下，如果你需要根据参数的类型，选择合适的行为，会如何做？</p>

<p>整篇文章会以对 AST 进行求值举例，其中 AST 定义如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">abc</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="n">LiteralValueType</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Expr</span><span class="p">(</span><span class="n">abc</span><span class="p">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Literal</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">LiteralValueType</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

<span class="k">class</span> <span class="nc">UnaryExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Expr</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
        <span class="n">self</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>

<span class="k">class</span> <span class="nc">BinaryExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">lhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span>
        <span class="n">self</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
</code></pre></div></div>

<p>一种非常容易想到的方式是利用反射机制：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># The code requires Python 3.10 and above
</span><span class="k">def</span> <span class="nf">my_eval</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LiteralValueType</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_eval_unary</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LiteralValueType</span><span class="p">:</span>
        <span class="n">match</span> <span class="n">op</span><span class="p">:</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">-</span><span class="sh">"</span><span class="p">:</span>   <span class="k">return</span> <span class="n">x</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">not</span><span class="sh">"</span><span class="p">:</span> <span class="k">return</span> <span class="ow">not</span> <span class="n">x</span>
            <span class="n">case</span> <span class="n">_</span>    <span class="p">:</span> <span class="k">raise</span> <span class="nc">Exception</span><span class="p">(</span><span class="sh">"</span><span class="s">unsupported unary operator: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_eval_binary</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LiteralValueType</span><span class="p">:</span>
        <span class="n">match</span> <span class="n">op</span><span class="p">:</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">+</span><span class="sh">"</span><span class="p">:</span>   <span class="k">return</span> <span class="n">lhs</span> <span class="o">+</span> <span class="n">rhs</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">-</span><span class="sh">"</span><span class="p">:</span>   <span class="k">return</span> <span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">*</span><span class="sh">"</span><span class="p">:</span>   <span class="k">return</span> <span class="n">lhs</span> <span class="o">*</span> <span class="n">rhs</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="p">:</span>   <span class="k">return</span> <span class="n">lhs</span> <span class="o">/</span> <span class="n">rhs</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">and</span><span class="sh">"</span><span class="p">:</span> <span class="k">return</span> <span class="n">lhs</span> <span class="ow">and</span> <span class="n">rhs</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">or</span><span class="sh">"</span><span class="p">:</span>  <span class="k">return</span> <span class="n">lhs</span> <span class="ow">or</span> <span class="n">rhs</span>
            <span class="n">case</span> <span class="n">_</span><span class="p">:</span>     <span class="k">raise</span> <span class="nc">Exception</span><span class="p">(</span><span class="sh">"</span><span class="s">unsupported binary operator: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>

    <span class="n">match</span> <span class="nf">type</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="n">case</span> <span class="n">Literal</span><span class="p">:</span>    <span class="k">return</span> <span class="n">e</span><span class="p">.</span><span class="n">value</span>
        <span class="n">case</span> <span class="n">UnaryExpr</span><span class="p">:</span>  <span class="k">return</span> <span class="nf">_eval_unary</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">op</span><span class="p">,</span> <span class="nf">my_eval</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">x</span><span class="p">))</span>
        <span class="n">case</span> <span class="n">BinaryExpr</span><span class="p">:</span> <span class="k">return</span> <span class="nf">_eval_binary</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">op</span><span class="p">,</span> <span class="nf">my_eval</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">lhs</span><span class="p">),</span> <span class="nf">my_eval</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">rhs</span><span class="p">))</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>          <span class="k">raise</span> <span class="nc">Exception</span><span class="p">(</span><span class="sh">"</span><span class="s">unknown expression type: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">type</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span>
</code></pre></div></div>

<p>这种方式的优点在于非常明确，但是缺点如下：</p>
<ul>
  <li>在不支持反射的语言中（例如，C 和 C++），这种方式很难实现（当然，在 C++ 中你可以用 <code class="language-plaintext highlighter-rouge">dynamic_cast</code>；对于 C，我能想到的一种补救方式是每个 <code class="language-plaintext highlighter-rouge">struct</code> 关联一个标签，不过既容易出错，又会增加运行期开销，属于雪上加霜）</li>
  <li>缺少可扩展性。一方面，如果增加新的节点类型，就需要在 <code class="language-plaintext highlighter-rouge">my_eval</code> 函数中增加相应的分支；另一方面，如果想要支持对 AST 的其他操作，完全没有可以复用的内容</li>
</ul>

<blockquote>
  <p>关于反射的效率，参见 StackOverflow 的<a href="https://stackoverflow.com/questions/3377576/if-reflection-is-inefficient-when-is-it-most-appropriate">这个问题</a>和<a href="https://softwareengineering.stackexchange.com/questions/143205/reflection-is-using-reflection-still-bad-or-slow-what-has-changed-with-ref">这个问题</a></p>
</blockquote>

<p>这里的核心问题在于：在有 sub-typing 的情况下，如何根据运行期对象的实际类型进行派发，Visitor 模式很好地解决了这个问题。不过，在正式进入 Visitor 模式之前，我们需要先来了解一下静态派发（static dispatching）和动态派发（dynamic dispatching）。</p>

<blockquote>
  <p>可能会有些读者认为将求值的功能分散到各个 <code class="language-plaintext highlighter-rouge">*Expr</code> 中更好：</p>

  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Expr</span><span class="p">(</span><span class="n">abc</span><span class="p">.</span><span class="n">ABC</span><span class="p">):</span>
   <span class="nd">@abc.abstractmethod</span>
   <span class="k">def</span> <span class="nf">do_eval</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">LiteralValueType</span><span class="p">:</span> <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Literal</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">do_eval</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
       <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">value</span>

<span class="k">class</span> <span class="nc">UnaryExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">do_eval</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
       <span class="n">match</span> <span class="n">self</span><span class="p">.</span><span class="n">op</span><span class="p">:</span>
           <span class="n">case</span> <span class="sh">"</span><span class="s">-</span><span class="sh">"</span><span class="p">:</span>   <span class="k">return</span> <span class="o">-</span><span class="n">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="nf">do_eval</span><span class="p">()</span>
           <span class="n">case</span> <span class="sh">"</span><span class="s">not</span><span class="sh">"</span><span class="p">:</span> <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="nf">do_eval</span><span class="p">()</span>
           <span class="n">case</span> <span class="n">_</span><span class="p">:</span>     <span class="k">raise</span> <span class="nc">Exception</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">BinaryExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">do_eval</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">match</span> <span class="n">self</span><span class="p">.</span><span class="n">op</span><span class="p">:</span>
            <span class="k">pass</span>
</code></pre></div>  </div>

  <p>这样的设计有两个问题：</p>
  <ul>
    <li>“求值”（至少我认为）不是 <code class="language-plaintext highlighter-rouge">*Expr</code> 的职责，<code class="language-plaintext highlighter-rouge">*Expr</code> 的职责是表示 AST 的数据结构，不符合单一职责原则</li>
    <li>假设将求值的功能放到了 <code class="language-plaintext highlighter-rouge">*Expr</code> 中，如果后续有其他需求（比如打印 AST），需要再次修改所有的 <code class="language-plaintext highlighter-rouge">*Expr</code>，这样不符合开闭原则</li>
  </ul>
</blockquote>

<h1 id="静态派发和动态派发">静态派发和动态派发</h1>

<h2 id="静态派发">静态派发</h2>

<p>所谓静态派发，就是根据编译期的声明类型选择合适的方法，例如：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">Time</span> <span class="o">=</span> <span class="kt">int64_t</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">DateTimeFormatter</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">format</span><span class="p">(</span><span class="k">const</span> <span class="n">Time</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">DateTimeFormatter</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">StandardDateTimeFormatter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DateTimeFormatter</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">format</span><span class="p">(</span><span class="k">const</span> <span class="n">Time</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"2006-01-02 15:04:05.006"</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">StandardDateTimeFormatter</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AmericanDateTimeFormatter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DateTimeFormatter</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">format</span><span class="p">(</span><span class="k">const</span> <span class="n">Time</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"Jan. 02, 2006 - 15:04:05"</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">AmericanDateTimeFormatter</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>如果使用如下调用：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">DateTimeFormatter</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"abstract"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">StandardDateTimeFormatter</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"standard"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">AmericanDateTimeFormatter</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"american"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"name of formatter: "</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">name</span><span class="p">;</span>
  <span class="n">DateTimeFormatter</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"standard"</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StandardDateTimeFormatter</span> <span class="p">{};</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"american"</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AmericanDateTimeFormatter</span> <span class="p">{};</span>
  <span class="p">}</span>
  <span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">);</span>

  <span class="k">delete</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>总是会打印 <code class="language-plaintext highlighter-rouge">abstract</code>，这是因为调用 <code class="language-plaintext highlighter-rouge">foo</code> 的哪个重载是在编译期确定的，而编译器唯一能够确切知道的信息就是 <code class="language-plaintext highlighter-rouge">f</code> 的类型为 <code class="language-plaintext highlighter-rouge">DateTimeFormatter</code>，所以就会选择第一个重载。</p>

<h2 id="动态派发">动态派发</h2>

<p>与静态派发相反，动态派发是根据运行期的实际类型选择方法，例如：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"name of formatter: "</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">name</span><span class="p">;</span>

  <span class="n">DateTimeFormatter</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"standard"</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StandardDateTimeFormatter</span> <span class="p">{};</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"american"</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AmericanDateTimeFormatter</span> <span class="p">{};</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">abort</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">f</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">();</span>

  <span class="k">delete</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果输入 <code class="language-plaintext highlighter-rouge">standard</code> 就会打印 <code class="language-plaintext highlighter-rouge">2006 ...</code>，如果输入 <code class="language-plaintext highlighter-rouge">american</code> 就会打印 <code class="language-plaintext highlighter-rouge">Jan ...</code>。</p>

<blockquote>
  <p>动态分派的实现机制参见<a href="">另一篇博文</a></p>
</blockquote>

<h1 id="visitor-模式">Visitor 模式</h1>

<p>回忆一下我们要解决的问题：在有 sub-typing 的情况下，如何根据运行期对象的实际类型进行派发。Visitor 模式的一个核心立足点是，对象自己最清楚自己的类型，由此，Visitor 模式解决这个问题的方式是：让对象自己选择调用哪个方法。</p>

<p>回到 AST 的例子，我们需要对 AST 做一些改造，给所有的 expression 增加一个 <code class="language-plaintext highlighter-rouge">accept</code> 方法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 我们的类定义出现了循环引用，这个 import 可以解决
</span><span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="k">class</span> <span class="nc">Expr</span><span class="p">(</span><span class="n">abc</span><span class="p">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="nd">@abc.abstractmethod</span>
    <span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Visitor</span><span class="p">):</span> <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Literal</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Visitor</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">v</span><span class="p">.</span><span class="nf">visit_literal</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">UnaryExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Visitor</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">v</span><span class="p">.</span><span class="nf">visit_unary_expr</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">BinaryExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Visitor</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">v</span><span class="p">.</span><span class="nf">visit_binary_expr</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Visitor</span><span class="p">(</span><span class="n">abc</span><span class="p">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Although this class is unnecessary (thanks to so-called duck-typing),
    showing its definition makes it more explicit
    </span><span class="sh">"""</span>
    <span class="nd">@abc.abstractmethod</span>
    <span class="k">def</span> <span class="nf">visit_literal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">Literal</span><span class="p">):</span> <span class="k">pass</span>
    <span class="nd">@abc.abstractmethod</span>
    <span class="k">def</span> <span class="nf">visit_unary_expr</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">UnaryExpr</span><span class="p">):</span> <span class="k">pass</span>
    <span class="nd">@abc.abstractmethod</span>
    <span class="k">def</span> <span class="nf">visit_binary_expr</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">BinaryExpr</span><span class="p">):</span> <span class="k">pass</span>
</code></pre></div></div>

<p>这样，我们就能这样改写求值功能：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">EvalVisitor</span><span class="p">(</span><span class="n">Visitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">visit_literal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">Literal</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">n</span><span class="p">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">visit_unary_expr</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">UnaryExpr</span><span class="p">):</span>
        <span class="n">match</span> <span class="n">expr</span><span class="p">.</span><span class="n">op</span><span class="p">:</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">-</span><span class="sh">"</span><span class="p">:</span>   <span class="k">return</span> <span class="o">-</span><span class="n">expr</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">not</span><span class="sh">"</span><span class="p">:</span> <span class="k">return</span> <span class="ow">not</span> <span class="n">expr</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
            <span class="n">case</span> <span class="n">_</span><span class="p">:</span>     <span class="k">raise</span> <span class="nc">Exception</span><span class="p">(</span><span class="sh">"</span><span class="s">unsupported unary operator: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">op</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">visit_binary_expr</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">BinaryExpr</span><span class="p">):</span>
        <span class="n">match</span> <span class="n">expr</span><span class="p">.</span><span class="n">op</span><span class="p">:</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">+</span><span class="sh">"</span><span class="p">:</span>   <span class="k">return</span> <span class="n">expr</span><span class="p">.</span><span class="n">lhs</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">expr</span><span class="p">.</span><span class="n">rhs</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">-</span><span class="sh">"</span><span class="p">:</span>   <span class="k">return</span> <span class="n">expr</span><span class="p">.</span><span class="n">lhs</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-</span> <span class="n">expr</span><span class="p">.</span><span class="n">rhs</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">*</span><span class="sh">"</span><span class="p">:</span>   <span class="k">return</span> <span class="n">expr</span><span class="p">.</span><span class="n">lhs</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">*</span> <span class="n">expr</span><span class="p">.</span><span class="n">rhs</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="p">:</span>   <span class="k">return</span> <span class="n">expr</span><span class="p">.</span><span class="n">lhs</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">/</span> <span class="n">expr</span><span class="p">.</span><span class="n">rhs</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">and</span><span class="sh">"</span><span class="p">:</span> <span class="k">return</span> <span class="n">expr</span><span class="p">.</span><span class="n">lhs</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="ow">and</span> <span class="n">expr</span><span class="p">.</span><span class="n">rhs</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
            <span class="n">case</span> <span class="sh">"</span><span class="s">or</span><span class="sh">"</span><span class="p">:</span>  <span class="k">return</span> <span class="n">expr</span><span class="p">.</span><span class="n">lhs</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="ow">or</span> <span class="n">expr</span><span class="p">.</span><span class="n">rhs</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
            <span class="n">case</span> <span class="n">_</span><span class="p">:</span>     <span class="k">raise</span> <span class="nc">Exception</span><span class="p">(</span><span class="sh">"</span><span class="s">unsupported binary operator: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">op</span><span class="p">))</span>
</code></pre></div></div>

<p>如下验证：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">expr</span> <span class="o">=</span> \
    <span class="nc">BinaryExpr</span><span class="p">(</span>
        <span class="sh">"</span><span class="s">+</span><span class="sh">"</span><span class="p">,</span>
        <span class="nc">BinaryExpr</span><span class="p">(</span>
            <span class="sh">"</span><span class="s">+</span><span class="sh">"</span><span class="p">,</span>
            <span class="nc">Literal</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="nc">BinaryExpr</span><span class="p">(</span>
                <span class="sh">"</span><span class="s">*</span><span class="sh">"</span><span class="p">,</span>
                <span class="nc">Literal</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
                <span class="nc">Literal</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
            <span class="p">),</span>
        <span class="p">),</span>
        <span class="nc">Literal</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
    <span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="nc">EvalVisitor</span><span class="p">()))</span>
</code></pre></div></div>

<p>需要注意的是，尽管我们用 AST 这种递归数据结构举例，但是 Visitor 模式也可适用于单个对象的情况。</p>

<h1 id="visitor-模式总是必须的吗">Visitor 模式总是必须的吗？</h1>

<p>答案自然是否定的。Paul Graham 有一场主题为<a href="http://www.norvig.com/design-patterns/">“Design Patterns in Dynamic Programming”</a>的演讲提到，23 种设计模式中，有 16 种是可以通过语言内建的机制取代的，其中就包括 Visitor 模式。</p>

<h2 id="多分派">多分派</h2>

<p>英文为“multiple dispatching”，也可称为“multimethod”，是指定义一组同名函数，在<strong>运行期</strong>根据<strong>所有</strong>参数的类型匹配调用目标（与编译期的函数重载相似，但不完全相同）。与多派发相对的是单派发（“single dispatch”），是指在运行期根据在其上调用方法的对象的类型选择合适的函数（也就是前文所说的“动态派发”）。</p>

<p>如果 Python 支持多分派，也许可以写成这样：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">sys</span>

<span class="k">class</span> <span class="nc">Visitor</span><span class="p">(</span><span class="n">abc</span><span class="p">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">BinaryExpr</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">UnaryExpr</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Literal</span><span class="p">):</span> <span class="k">pass</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="nf">parse_to_ast</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="nc">EvalVisitor</span><span class="p">().</span><span class="nf">visit</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</code></pre></div></div>

<p>实际上，Visitor 模式在某种程度上实现了基于 <code class="language-plaintext highlighter-rouge">v: Visitor</code> 和 <code class="language-plaintext highlighter-rouge">e: Expr</code> 的多分派，调用 <code class="language-plaintext highlighter-rouge">Expr::accept</code> 时是一次动态派发，调用 <code class="language-plaintext highlighter-rouge">Visitor::visit</code> 时是一次静态派发，所以理论上来讲可以通过增加分派次数实现支持更多参数的多分派。</p>

<p>除了解决开篇提出的基于反射的方案的几个缺点之外，Visitor 模式也充分利用了类型系统，降低了出错概率。</p>

<h1 id="从程序设计语言的角度看-visitor-模式">从程序设计语言的角度看 Visitor 模式</h1>

<h2 id="oop-和-fp-组织程序的方式">OOP 和 FP 组织程序的方式</h2>

<p>所有的程序都包含类型和操作两个方面，然而 FP 和 OOP 组织二者的方式是不同的——FP 倾向于将对于多种类型的操作组织在一起，而 OOP 倾向于将多种操作组织在同一个类型中。假设现在有 A、B 和 C 三种类型，每种类型都有 foo、bar 和 baz 三种操作，我们可以画出如下的类型/操作矩阵：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">类型 \ 操作</th>
      <th style="text-align: left">foo</th>
      <th style="text-align: left">bar</th>
      <th style="text-align: left">baz</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">A</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left"> </td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">B</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left"> </td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">C</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left"> </td>
      <td style="text-align: left"> </td>
    </tr>
  </tbody>
</table>

<p>OOP 的组织方式会是这样的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Base</span>
  <span class="k">def</span> <span class="nf">foo</span> <span class="p">;</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">bar</span> <span class="p">;</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">baz</span> <span class="p">;</span> <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">A</span> <span class="o">&lt;</span> <span class="no">Base</span> <span class="k">end</span>
<span class="k">class</span> <span class="nc">B</span> <span class="o">&lt;</span> <span class="no">Base</span> <span class="k">end</span>
<span class="k">class</span> <span class="nc">C</span> <span class="o">&lt;</span> <span class="no">Base</span> <span class="k">end</span>
</code></pre></div></div>

<p>我们将其称为“按行”组织。而 FP 会是这样的：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Base</span> <span class="p">{</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="p">}</span>

<span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span> <span class="n">Base</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">x</span> <span class="p">{</span>
      <span class="n">A</span> <span class="k">=&gt;</span> <span class="s">"A::foo"</span><span class="p">,</span>
      <span class="n">B</span> <span class="k">=&gt;</span> <span class="s">"B::foo"</span><span class="p">,</span>
      <span class="n">C</span> <span class="k">=&gt;</span> <span class="s">"C::foo"</span><span class="p">,</span>
    <span class="p">}</span><span class="nf">.to_owned</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">bar</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Base</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span> <span class="nd">unimplemented!</span><span class="p">();</span> <span class="p">}</span>
<span class="k">fn</span> <span class="nf">baz</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Base</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span> <span class="nd">unimplemented!</span><span class="p">();</span> <span class="p">}</span>
</code></pre></div></div>

<p>我们将其称为“按列”组织。</p>

<p>在 OOP 中，增加新类型是很容易的——只需要继承 <code class="language-plaintext highlighter-rouge">Base</code> 即可，而要增加操作，就会比较麻烦——可能需要在所有类中添加这个操作；而在 FP 中，增加新操作比较容易——只需要实现一个新的函数，在其中使用模式匹配即可，而要增加类型就会比较麻烦——需要在所有操作的模式匹配中增加这个新类型。</p>

<blockquote>
  <p>前文提到的多分派可以容易的支持两个方向的扩展</p>
</blockquote>

<h2 id="visitor-模式的作用">Visitor 模式的作用</h2>

<p>Visitor 模式就改变了上述 OOP 难以增加新操作的问题——要增加一组新的操作，只需要创建一个新类，实现 <code class="language-plaintext highlighter-rouge">Visitor</code> 接口即可。当然，凡事都是有代价的，Visitor 模式让增加新类型变得困难了。延续上面 AST 的例子，如果要增加一个 <code class="language-plaintext highlighter-rouge">Variable</code> 节点，就需要在所有的 <code class="language-plaintext highlighter-rouge">Visitor</code> 中增加 <code class="language-plaintext highlighter-rouge">visit_variable</code> 方法。</p>

<blockquote>
  <p>Visitor 模式使得可以在 OOP 中模拟 FP 的行为，那么有没有一种方式能够让我们在 FP 中模拟 OOP 的行为呢？</p>

  <blockquote>
    <p>这是<a href="https://craftinginterpreters.com/">《Crafting Interpreters》</a>中的思考题</p>
  </blockquote>

  <ul>
    <li>Ocaml 中提供了 <a href="https://ocaml.org/docs/modules">module 机制</a>，可以用来实现更加偏向于 OOP 风格的封装。</li>
    <li>Haskell 的 <a href="https://book.realworldhaskell.org/read/using-typeclasses.html#:~:text=Typeclasses%20are%20among%20the%20most%20powerful%20features%20in,features%20such%20as%20equality%20testing%20and%20numeric%20operators.">typeclass</a> 也是这种组织方式（至少我理解是这样）</li>
    <li>《Crafting Interpreters》也提供了一种方案：通过 tuple 或 record 维护一个类型所有的函数</li>
  </ul>
</blockquote>

<h1 id="其他">其他</h1>

<h1 id="与其他模式的关系">与其他模式的关系</h1>

<p>由于 Visitor 模式通常操作的都是复合结构，所以该模式与 Composite 模式有很强的关系，以 AST 为例：</p>

<p><img src="./images/ast-composite.png" alt="" /></p>

<!--
```plantuml
interface Expr {}

class BinaryExpr implements Expr {
    + op: String
    + lhs: Expr
    + rhs: Expr
}

class UnaryExpr implements Expr {
    + op: String
    + x: Expr
}

class Literal implements Expr {
    + value: Int | Float | Bool
}

BinaryExpr -- Expr
UnaryExpr -- Expr
```

-->

<h1 id="杂项">杂项</h1>

<h2 id="简化-element-的定义">简化 Element 的定义</h2>

<p>在 Python 3.x 中，可以如下实现：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">abc</span>

<span class="k">class</span> <span class="nc">Visitable</span><span class="p">(</span><span class="n">abc</span><span class="p">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Visitor</span><span class="p">):</span>
        <span class="n">method</span> <span class="o">=</span> <span class="sh">"</span><span class="s">visit_</span><span class="sh">"</span> <span class="o">+</span> <span class="nf">type</span><span class="p">(</span><span class="n">self</span><span class="p">).</span><span class="n">__name__</span>
        <span class="k">return</span> <span class="nf">getattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="n">self</span><span class="p">)</span>
</code></pre></div></div>

<p>Ruby 中可以这样实现：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Visitable</span>
  <span class="k">def</span> <span class="nf">accept</span> <span class="n">v</span>
    <span class="nb">method</span> <span class="o">=</span> <span class="s2">"visit_"</span> <span class="o">+</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">name</span>
    <span class="n">v</span><span class="p">.</span><span class="nf">send</span> <span class="nb">method</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">,</span> <span class="nb">self</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p>如果使用函数重载定义 <code class="language-plaintext highlighter-rouge">visit</code>，这种方法显然是行不通的，而且（就我的知识水平而言）使用重载的方式无法定义一个通用的 <code class="language-plaintext highlighter-rouge">Visitable</code> 类（因为静态派发）</p>
</blockquote>

<h2 id="参数传递">参数传递</h2>

<p>我想到的方法：</p>
<ul>
  <li>通过 <code class="language-plaintext highlighter-rouge">visit*</code> 可变参数实现</li>
  <li>定义一个参数类，所有的参数组成其字段，这种方式可以改成定义一个 marker interface 然后通过类型转换的方式实现</li>
</ul>

<h1 id="参考">参考</h1>

<ol>
  <li><a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor pattern - Wikipedia</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Multiple_dispatch">Multiple dispatch - Wikipedia</a>
    <ol>
      <li>Julia 是一种支持多分派的语言，可以参考 https://www.matecdev.com/posts/julia-multiple-dispatch.html</li>
      <li><a href="https://en.wikipedia.org/wiki/Double_dispatch">Double dispatch - Wikipedia</a></li>
    </ol>
  </li>
</ol>
